// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/traPtitech/neoshowcase/pkg/domain"
	"github.com/traPtitech/neoshowcase/pkg/infrastructure/grpc/pb"
	"sync"
)

// Ensure, that ControllerServiceClientMock does implement domain.ControllerServiceClient.
// If this is not the case, regenerate this file with moq.
var _ domain.ControllerServiceClient = &ControllerServiceClientMock{}

// ControllerServiceClientMock is a mock implementation of domain.ControllerServiceClient.
//
//	func TestSomethingThatUsesControllerServiceClient(t *testing.T) {
//
//		// make and configure a mocked domain.ControllerServiceClient
//		mockedControllerServiceClient := &ControllerServiceClientMock{
//			CancelBuildFunc: func(ctx context.Context, buildID string) error {
//				panic("mock out the CancelBuild method")
//			},
//			CancelBuildLocalFunc: func(ctx context.Context, buildID string) error {
//				panic("mock out the CancelBuildLocal method")
//			},
//			DiscoverBuildLogInstanceFunc: func(ctx context.Context, buildID string) (*pb.AddressInfo, error) {
//				panic("mock out the DiscoverBuildLogInstance method")
//			},
//			DiscoverBuildLogLocalFunc: func(ctx context.Context, buildID string) (*pb.AddressInfo, error) {
//				panic("mock out the DiscoverBuildLogLocal method")
//			},
//			FetchRepositoryFunc: func(ctx context.Context, repositoryID string) error {
//				panic("mock out the FetchRepository method")
//			},
//			GetSystemInfoFunc: func(ctx context.Context) (*domain.SystemInfo, error) {
//				panic("mock out the GetSystemInfo method")
//			},
//			RegisterBuildFunc: func(ctx context.Context, appID string) error {
//				panic("mock out the RegisterBuild method")
//			},
//			StartBuildFunc: func(ctx context.Context) error {
//				panic("mock out the StartBuild method")
//			},
//			StartBuildLocalFunc: func(ctx context.Context) error {
//				panic("mock out the StartBuildLocal method")
//			},
//			StreamBuildLogFunc: func(ctx context.Context, address string, buildID string) (<-chan *pb.BuildLog, error) {
//				panic("mock out the StreamBuildLog method")
//			},
//			SyncDeploymentsFunc: func(ctx context.Context) error {
//				panic("mock out the SyncDeployments method")
//			},
//			SyncDeploymentsLocalFunc: func(ctx context.Context) error {
//				panic("mock out the SyncDeploymentsLocal method")
//			},
//		}
//
//		// use mockedControllerServiceClient in code that requires domain.ControllerServiceClient
//		// and then make assertions.
//
//	}
type ControllerServiceClientMock struct {
	// CancelBuildFunc mocks the CancelBuild method.
	CancelBuildFunc func(ctx context.Context, buildID string) error

	// CancelBuildLocalFunc mocks the CancelBuildLocal method.
	CancelBuildLocalFunc func(ctx context.Context, buildID string) error

	// DiscoverBuildLogInstanceFunc mocks the DiscoverBuildLogInstance method.
	DiscoverBuildLogInstanceFunc func(ctx context.Context, buildID string) (*pb.AddressInfo, error)

	// DiscoverBuildLogLocalFunc mocks the DiscoverBuildLogLocal method.
	DiscoverBuildLogLocalFunc func(ctx context.Context, buildID string) (*pb.AddressInfo, error)

	// FetchRepositoryFunc mocks the FetchRepository method.
	FetchRepositoryFunc func(ctx context.Context, repositoryID string) error

	// GetSystemInfoFunc mocks the GetSystemInfo method.
	GetSystemInfoFunc func(ctx context.Context) (*domain.SystemInfo, error)

	// RegisterBuildFunc mocks the RegisterBuild method.
	RegisterBuildFunc func(ctx context.Context, appID string) error

	// StartBuildFunc mocks the StartBuild method.
	StartBuildFunc func(ctx context.Context) error

	// StartBuildLocalFunc mocks the StartBuildLocal method.
	StartBuildLocalFunc func(ctx context.Context) error

	// StreamBuildLogFunc mocks the StreamBuildLog method.
	StreamBuildLogFunc func(ctx context.Context, address string, buildID string) (<-chan *pb.BuildLog, error)

	// SyncDeploymentsFunc mocks the SyncDeployments method.
	SyncDeploymentsFunc func(ctx context.Context) error

	// SyncDeploymentsLocalFunc mocks the SyncDeploymentsLocal method.
	SyncDeploymentsLocalFunc func(ctx context.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// CancelBuild holds details about calls to the CancelBuild method.
		CancelBuild []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BuildID is the buildID argument value.
			BuildID string
		}
		// CancelBuildLocal holds details about calls to the CancelBuildLocal method.
		CancelBuildLocal []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BuildID is the buildID argument value.
			BuildID string
		}
		// DiscoverBuildLogInstance holds details about calls to the DiscoverBuildLogInstance method.
		DiscoverBuildLogInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BuildID is the buildID argument value.
			BuildID string
		}
		// DiscoverBuildLogLocal holds details about calls to the DiscoverBuildLogLocal method.
		DiscoverBuildLogLocal []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BuildID is the buildID argument value.
			BuildID string
		}
		// FetchRepository holds details about calls to the FetchRepository method.
		FetchRepository []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepositoryID is the repositoryID argument value.
			RepositoryID string
		}
		// GetSystemInfo holds details about calls to the GetSystemInfo method.
		GetSystemInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RegisterBuild holds details about calls to the RegisterBuild method.
		RegisterBuild []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AppID is the appID argument value.
			AppID string
		}
		// StartBuild holds details about calls to the StartBuild method.
		StartBuild []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// StartBuildLocal holds details about calls to the StartBuildLocal method.
		StartBuildLocal []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// StreamBuildLog holds details about calls to the StreamBuildLog method.
		StreamBuildLog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
			// BuildID is the buildID argument value.
			BuildID string
		}
		// SyncDeployments holds details about calls to the SyncDeployments method.
		SyncDeployments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SyncDeploymentsLocal holds details about calls to the SyncDeploymentsLocal method.
		SyncDeploymentsLocal []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockCancelBuild              sync.RWMutex
	lockCancelBuildLocal         sync.RWMutex
	lockDiscoverBuildLogInstance sync.RWMutex
	lockDiscoverBuildLogLocal    sync.RWMutex
	lockFetchRepository          sync.RWMutex
	lockGetSystemInfo            sync.RWMutex
	lockRegisterBuild            sync.RWMutex
	lockStartBuild               sync.RWMutex
	lockStartBuildLocal          sync.RWMutex
	lockStreamBuildLog           sync.RWMutex
	lockSyncDeployments          sync.RWMutex
	lockSyncDeploymentsLocal     sync.RWMutex
}

// CancelBuild calls CancelBuildFunc.
func (mock *ControllerServiceClientMock) CancelBuild(ctx context.Context, buildID string) error {
	callInfo := struct {
		Ctx     context.Context
		BuildID string
	}{
		Ctx:     ctx,
		BuildID: buildID,
	}
	mock.lockCancelBuild.Lock()
	mock.calls.CancelBuild = append(mock.calls.CancelBuild, callInfo)
	mock.lockCancelBuild.Unlock()
	if mock.CancelBuildFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CancelBuildFunc(ctx, buildID)
}

// CancelBuildCalls gets all the calls that were made to CancelBuild.
// Check the length with:
//
//	len(mockedControllerServiceClient.CancelBuildCalls())
func (mock *ControllerServiceClientMock) CancelBuildCalls() []struct {
	Ctx     context.Context
	BuildID string
} {
	var calls []struct {
		Ctx     context.Context
		BuildID string
	}
	mock.lockCancelBuild.RLock()
	calls = mock.calls.CancelBuild
	mock.lockCancelBuild.RUnlock()
	return calls
}

// CancelBuildLocal calls CancelBuildLocalFunc.
func (mock *ControllerServiceClientMock) CancelBuildLocal(ctx context.Context, buildID string) error {
	callInfo := struct {
		Ctx     context.Context
		BuildID string
	}{
		Ctx:     ctx,
		BuildID: buildID,
	}
	mock.lockCancelBuildLocal.Lock()
	mock.calls.CancelBuildLocal = append(mock.calls.CancelBuildLocal, callInfo)
	mock.lockCancelBuildLocal.Unlock()
	if mock.CancelBuildLocalFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CancelBuildLocalFunc(ctx, buildID)
}

// CancelBuildLocalCalls gets all the calls that were made to CancelBuildLocal.
// Check the length with:
//
//	len(mockedControllerServiceClient.CancelBuildLocalCalls())
func (mock *ControllerServiceClientMock) CancelBuildLocalCalls() []struct {
	Ctx     context.Context
	BuildID string
} {
	var calls []struct {
		Ctx     context.Context
		BuildID string
	}
	mock.lockCancelBuildLocal.RLock()
	calls = mock.calls.CancelBuildLocal
	mock.lockCancelBuildLocal.RUnlock()
	return calls
}

// DiscoverBuildLogInstance calls DiscoverBuildLogInstanceFunc.
func (mock *ControllerServiceClientMock) DiscoverBuildLogInstance(ctx context.Context, buildID string) (*pb.AddressInfo, error) {
	callInfo := struct {
		Ctx     context.Context
		BuildID string
	}{
		Ctx:     ctx,
		BuildID: buildID,
	}
	mock.lockDiscoverBuildLogInstance.Lock()
	mock.calls.DiscoverBuildLogInstance = append(mock.calls.DiscoverBuildLogInstance, callInfo)
	mock.lockDiscoverBuildLogInstance.Unlock()
	if mock.DiscoverBuildLogInstanceFunc == nil {
		var (
			addressInfoOut *pb.AddressInfo
			errOut         error
		)
		return addressInfoOut, errOut
	}
	return mock.DiscoverBuildLogInstanceFunc(ctx, buildID)
}

// DiscoverBuildLogInstanceCalls gets all the calls that were made to DiscoverBuildLogInstance.
// Check the length with:
//
//	len(mockedControllerServiceClient.DiscoverBuildLogInstanceCalls())
func (mock *ControllerServiceClientMock) DiscoverBuildLogInstanceCalls() []struct {
	Ctx     context.Context
	BuildID string
} {
	var calls []struct {
		Ctx     context.Context
		BuildID string
	}
	mock.lockDiscoverBuildLogInstance.RLock()
	calls = mock.calls.DiscoverBuildLogInstance
	mock.lockDiscoverBuildLogInstance.RUnlock()
	return calls
}

// DiscoverBuildLogLocal calls DiscoverBuildLogLocalFunc.
func (mock *ControllerServiceClientMock) DiscoverBuildLogLocal(ctx context.Context, buildID string) (*pb.AddressInfo, error) {
	callInfo := struct {
		Ctx     context.Context
		BuildID string
	}{
		Ctx:     ctx,
		BuildID: buildID,
	}
	mock.lockDiscoverBuildLogLocal.Lock()
	mock.calls.DiscoverBuildLogLocal = append(mock.calls.DiscoverBuildLogLocal, callInfo)
	mock.lockDiscoverBuildLogLocal.Unlock()
	if mock.DiscoverBuildLogLocalFunc == nil {
		var (
			addressInfoOut *pb.AddressInfo
			errOut         error
		)
		return addressInfoOut, errOut
	}
	return mock.DiscoverBuildLogLocalFunc(ctx, buildID)
}

// DiscoverBuildLogLocalCalls gets all the calls that were made to DiscoverBuildLogLocal.
// Check the length with:
//
//	len(mockedControllerServiceClient.DiscoverBuildLogLocalCalls())
func (mock *ControllerServiceClientMock) DiscoverBuildLogLocalCalls() []struct {
	Ctx     context.Context
	BuildID string
} {
	var calls []struct {
		Ctx     context.Context
		BuildID string
	}
	mock.lockDiscoverBuildLogLocal.RLock()
	calls = mock.calls.DiscoverBuildLogLocal
	mock.lockDiscoverBuildLogLocal.RUnlock()
	return calls
}

// FetchRepository calls FetchRepositoryFunc.
func (mock *ControllerServiceClientMock) FetchRepository(ctx context.Context, repositoryID string) error {
	callInfo := struct {
		Ctx          context.Context
		RepositoryID string
	}{
		Ctx:          ctx,
		RepositoryID: repositoryID,
	}
	mock.lockFetchRepository.Lock()
	mock.calls.FetchRepository = append(mock.calls.FetchRepository, callInfo)
	mock.lockFetchRepository.Unlock()
	if mock.FetchRepositoryFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.FetchRepositoryFunc(ctx, repositoryID)
}

// FetchRepositoryCalls gets all the calls that were made to FetchRepository.
// Check the length with:
//
//	len(mockedControllerServiceClient.FetchRepositoryCalls())
func (mock *ControllerServiceClientMock) FetchRepositoryCalls() []struct {
	Ctx          context.Context
	RepositoryID string
} {
	var calls []struct {
		Ctx          context.Context
		RepositoryID string
	}
	mock.lockFetchRepository.RLock()
	calls = mock.calls.FetchRepository
	mock.lockFetchRepository.RUnlock()
	return calls
}

// GetSystemInfo calls GetSystemInfoFunc.
func (mock *ControllerServiceClientMock) GetSystemInfo(ctx context.Context) (*domain.SystemInfo, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetSystemInfo.Lock()
	mock.calls.GetSystemInfo = append(mock.calls.GetSystemInfo, callInfo)
	mock.lockGetSystemInfo.Unlock()
	if mock.GetSystemInfoFunc == nil {
		var (
			systemInfoOut *domain.SystemInfo
			errOut        error
		)
		return systemInfoOut, errOut
	}
	return mock.GetSystemInfoFunc(ctx)
}

// GetSystemInfoCalls gets all the calls that were made to GetSystemInfo.
// Check the length with:
//
//	len(mockedControllerServiceClient.GetSystemInfoCalls())
func (mock *ControllerServiceClientMock) GetSystemInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetSystemInfo.RLock()
	calls = mock.calls.GetSystemInfo
	mock.lockGetSystemInfo.RUnlock()
	return calls
}

// RegisterBuild calls RegisterBuildFunc.
func (mock *ControllerServiceClientMock) RegisterBuild(ctx context.Context, appID string) error {
	callInfo := struct {
		Ctx   context.Context
		AppID string
	}{
		Ctx:   ctx,
		AppID: appID,
	}
	mock.lockRegisterBuild.Lock()
	mock.calls.RegisterBuild = append(mock.calls.RegisterBuild, callInfo)
	mock.lockRegisterBuild.Unlock()
	if mock.RegisterBuildFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.RegisterBuildFunc(ctx, appID)
}

// RegisterBuildCalls gets all the calls that were made to RegisterBuild.
// Check the length with:
//
//	len(mockedControllerServiceClient.RegisterBuildCalls())
func (mock *ControllerServiceClientMock) RegisterBuildCalls() []struct {
	Ctx   context.Context
	AppID string
} {
	var calls []struct {
		Ctx   context.Context
		AppID string
	}
	mock.lockRegisterBuild.RLock()
	calls = mock.calls.RegisterBuild
	mock.lockRegisterBuild.RUnlock()
	return calls
}

// StartBuild calls StartBuildFunc.
func (mock *ControllerServiceClientMock) StartBuild(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStartBuild.Lock()
	mock.calls.StartBuild = append(mock.calls.StartBuild, callInfo)
	mock.lockStartBuild.Unlock()
	if mock.StartBuildFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.StartBuildFunc(ctx)
}

// StartBuildCalls gets all the calls that were made to StartBuild.
// Check the length with:
//
//	len(mockedControllerServiceClient.StartBuildCalls())
func (mock *ControllerServiceClientMock) StartBuildCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStartBuild.RLock()
	calls = mock.calls.StartBuild
	mock.lockStartBuild.RUnlock()
	return calls
}

// StartBuildLocal calls StartBuildLocalFunc.
func (mock *ControllerServiceClientMock) StartBuildLocal(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStartBuildLocal.Lock()
	mock.calls.StartBuildLocal = append(mock.calls.StartBuildLocal, callInfo)
	mock.lockStartBuildLocal.Unlock()
	if mock.StartBuildLocalFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.StartBuildLocalFunc(ctx)
}

// StartBuildLocalCalls gets all the calls that were made to StartBuildLocal.
// Check the length with:
//
//	len(mockedControllerServiceClient.StartBuildLocalCalls())
func (mock *ControllerServiceClientMock) StartBuildLocalCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStartBuildLocal.RLock()
	calls = mock.calls.StartBuildLocal
	mock.lockStartBuildLocal.RUnlock()
	return calls
}

// StreamBuildLog calls StreamBuildLogFunc.
func (mock *ControllerServiceClientMock) StreamBuildLog(ctx context.Context, address string, buildID string) (<-chan *pb.BuildLog, error) {
	callInfo := struct {
		Ctx     context.Context
		Address string
		BuildID string
	}{
		Ctx:     ctx,
		Address: address,
		BuildID: buildID,
	}
	mock.lockStreamBuildLog.Lock()
	mock.calls.StreamBuildLog = append(mock.calls.StreamBuildLog, callInfo)
	mock.lockStreamBuildLog.Unlock()
	if mock.StreamBuildLogFunc == nil {
		var (
			buildLogChOut <-chan *pb.BuildLog
			errOut        error
		)
		return buildLogChOut, errOut
	}
	return mock.StreamBuildLogFunc(ctx, address, buildID)
}

// StreamBuildLogCalls gets all the calls that were made to StreamBuildLog.
// Check the length with:
//
//	len(mockedControllerServiceClient.StreamBuildLogCalls())
func (mock *ControllerServiceClientMock) StreamBuildLogCalls() []struct {
	Ctx     context.Context
	Address string
	BuildID string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
		BuildID string
	}
	mock.lockStreamBuildLog.RLock()
	calls = mock.calls.StreamBuildLog
	mock.lockStreamBuildLog.RUnlock()
	return calls
}

// SyncDeployments calls SyncDeploymentsFunc.
func (mock *ControllerServiceClientMock) SyncDeployments(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSyncDeployments.Lock()
	mock.calls.SyncDeployments = append(mock.calls.SyncDeployments, callInfo)
	mock.lockSyncDeployments.Unlock()
	if mock.SyncDeploymentsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SyncDeploymentsFunc(ctx)
}

// SyncDeploymentsCalls gets all the calls that were made to SyncDeployments.
// Check the length with:
//
//	len(mockedControllerServiceClient.SyncDeploymentsCalls())
func (mock *ControllerServiceClientMock) SyncDeploymentsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSyncDeployments.RLock()
	calls = mock.calls.SyncDeployments
	mock.lockSyncDeployments.RUnlock()
	return calls
}

// SyncDeploymentsLocal calls SyncDeploymentsLocalFunc.
func (mock *ControllerServiceClientMock) SyncDeploymentsLocal(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSyncDeploymentsLocal.Lock()
	mock.calls.SyncDeploymentsLocal = append(mock.calls.SyncDeploymentsLocal, callInfo)
	mock.lockSyncDeploymentsLocal.Unlock()
	if mock.SyncDeploymentsLocalFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SyncDeploymentsLocalFunc(ctx)
}

// SyncDeploymentsLocalCalls gets all the calls that were made to SyncDeploymentsLocal.
// Check the length with:
//
//	len(mockedControllerServiceClient.SyncDeploymentsLocalCalls())
func (mock *ControllerServiceClientMock) SyncDeploymentsLocalCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSyncDeploymentsLocal.RLock()
	calls = mock.calls.SyncDeploymentsLocal
	mock.lockSyncDeploymentsLocal.RUnlock()
	return calls
}
