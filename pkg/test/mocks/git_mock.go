// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/traPtitech/neoshowcase/pkg/domain"
	"sync"
)

// Ensure, that GitServiceMock does implement domain.GitService.
// If this is not the case, regenerate this file with moq.
var _ domain.GitService = &GitServiceMock{}

// GitServiceMock is a mock implementation of domain.GitService.
//
//	func TestSomethingThatUsesGitService(t *testing.T) {
//
//		// make and configure a mocked domain.GitService
//		mockedGitService := &GitServiceMock{
//			CloneRepositoryFunc: func(ctx context.Context, dir string, repo *domain.Repository, commitHash string) error {
//				panic("mock out the CloneRepository method")
//			},
//			CreateBareRepositoryFunc: func(dir string, repo *domain.Repository) (domain.GitRepository, error) {
//				panic("mock out the CreateBareRepository method")
//			},
//			ResolveRefsFunc: func(ctx context.Context, repo *domain.Repository) (map[string]string, error) {
//				panic("mock out the ResolveRefs method")
//			},
//		}
//
//		// use mockedGitService in code that requires domain.GitService
//		// and then make assertions.
//
//	}
type GitServiceMock struct {
	// CloneRepositoryFunc mocks the CloneRepository method.
	CloneRepositoryFunc func(ctx context.Context, dir string, repo *domain.Repository, commitHash string) error

	// CreateBareRepositoryFunc mocks the CreateBareRepository method.
	CreateBareRepositoryFunc func(dir string, repo *domain.Repository) (domain.GitRepository, error)

	// ResolveRefsFunc mocks the ResolveRefs method.
	ResolveRefsFunc func(ctx context.Context, repo *domain.Repository) (map[string]string, error)

	// calls tracks calls to the methods.
	calls struct {
		// CloneRepository holds details about calls to the CloneRepository method.
		CloneRepository []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dir is the dir argument value.
			Dir string
			// Repo is the repo argument value.
			Repo *domain.Repository
			// CommitHash is the commitHash argument value.
			CommitHash string
		}
		// CreateBareRepository holds details about calls to the CreateBareRepository method.
		CreateBareRepository []struct {
			// Dir is the dir argument value.
			Dir string
			// Repo is the repo argument value.
			Repo *domain.Repository
		}
		// ResolveRefs holds details about calls to the ResolveRefs method.
		ResolveRefs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Repo is the repo argument value.
			Repo *domain.Repository
		}
	}
	lockCloneRepository      sync.RWMutex
	lockCreateBareRepository sync.RWMutex
	lockResolveRefs          sync.RWMutex
}

// CloneRepository calls CloneRepositoryFunc.
func (mock *GitServiceMock) CloneRepository(ctx context.Context, dir string, repo *domain.Repository, commitHash string) error {
	callInfo := struct {
		Ctx        context.Context
		Dir        string
		Repo       *domain.Repository
		CommitHash string
	}{
		Ctx:        ctx,
		Dir:        dir,
		Repo:       repo,
		CommitHash: commitHash,
	}
	mock.lockCloneRepository.Lock()
	mock.calls.CloneRepository = append(mock.calls.CloneRepository, callInfo)
	mock.lockCloneRepository.Unlock()
	if mock.CloneRepositoryFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CloneRepositoryFunc(ctx, dir, repo, commitHash)
}

// CloneRepositoryCalls gets all the calls that were made to CloneRepository.
// Check the length with:
//
//	len(mockedGitService.CloneRepositoryCalls())
func (mock *GitServiceMock) CloneRepositoryCalls() []struct {
	Ctx        context.Context
	Dir        string
	Repo       *domain.Repository
	CommitHash string
} {
	var calls []struct {
		Ctx        context.Context
		Dir        string
		Repo       *domain.Repository
		CommitHash string
	}
	mock.lockCloneRepository.RLock()
	calls = mock.calls.CloneRepository
	mock.lockCloneRepository.RUnlock()
	return calls
}

// CreateBareRepository calls CreateBareRepositoryFunc.
func (mock *GitServiceMock) CreateBareRepository(dir string, repo *domain.Repository) (domain.GitRepository, error) {
	callInfo := struct {
		Dir  string
		Repo *domain.Repository
	}{
		Dir:  dir,
		Repo: repo,
	}
	mock.lockCreateBareRepository.Lock()
	mock.calls.CreateBareRepository = append(mock.calls.CreateBareRepository, callInfo)
	mock.lockCreateBareRepository.Unlock()
	if mock.CreateBareRepositoryFunc == nil {
		var (
			gitRepositoryOut domain.GitRepository
			errOut           error
		)
		return gitRepositoryOut, errOut
	}
	return mock.CreateBareRepositoryFunc(dir, repo)
}

// CreateBareRepositoryCalls gets all the calls that were made to CreateBareRepository.
// Check the length with:
//
//	len(mockedGitService.CreateBareRepositoryCalls())
func (mock *GitServiceMock) CreateBareRepositoryCalls() []struct {
	Dir  string
	Repo *domain.Repository
} {
	var calls []struct {
		Dir  string
		Repo *domain.Repository
	}
	mock.lockCreateBareRepository.RLock()
	calls = mock.calls.CreateBareRepository
	mock.lockCreateBareRepository.RUnlock()
	return calls
}

// ResolveRefs calls ResolveRefsFunc.
func (mock *GitServiceMock) ResolveRefs(ctx context.Context, repo *domain.Repository) (map[string]string, error) {
	callInfo := struct {
		Ctx  context.Context
		Repo *domain.Repository
	}{
		Ctx:  ctx,
		Repo: repo,
	}
	mock.lockResolveRefs.Lock()
	mock.calls.ResolveRefs = append(mock.calls.ResolveRefs, callInfo)
	mock.lockResolveRefs.Unlock()
	if mock.ResolveRefsFunc == nil {
		var (
			refToCommitOut map[string]string
			errOut         error
		)
		return refToCommitOut, errOut
	}
	return mock.ResolveRefsFunc(ctx, repo)
}

// ResolveRefsCalls gets all the calls that were made to ResolveRefs.
// Check the length with:
//
//	len(mockedGitService.ResolveRefsCalls())
func (mock *GitServiceMock) ResolveRefsCalls() []struct {
	Ctx  context.Context
	Repo *domain.Repository
} {
	var calls []struct {
		Ctx  context.Context
		Repo *domain.Repository
	}
	mock.lockResolveRefs.RLock()
	calls = mock.calls.ResolveRefs
	mock.lockResolveRefs.RUnlock()
	return calls
}

// Ensure, that GitRepositoryMock does implement domain.GitRepository.
// If this is not the case, regenerate this file with moq.
var _ domain.GitRepository = &GitRepositoryMock{}

// GitRepositoryMock is a mock implementation of domain.GitRepository.
//
//	func TestSomethingThatUsesGitRepository(t *testing.T) {
//
//		// make and configure a mocked domain.GitRepository
//		mockedGitRepository := &GitRepositoryMock{
//			FetchFunc: func(ctx context.Context, hashes []string) error {
//				panic("mock out the Fetch method")
//			},
//			GetCommitFunc: func(hash string) (*domain.RepositoryCommit, error) {
//				panic("mock out the GetCommit method")
//			},
//		}
//
//		// use mockedGitRepository in code that requires domain.GitRepository
//		// and then make assertions.
//
//	}
type GitRepositoryMock struct {
	// FetchFunc mocks the Fetch method.
	FetchFunc func(ctx context.Context, hashes []string) error

	// GetCommitFunc mocks the GetCommit method.
	GetCommitFunc func(hash string) (*domain.RepositoryCommit, error)

	// calls tracks calls to the methods.
	calls struct {
		// Fetch holds details about calls to the Fetch method.
		Fetch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hashes is the hashes argument value.
			Hashes []string
		}
		// GetCommit holds details about calls to the GetCommit method.
		GetCommit []struct {
			// Hash is the hash argument value.
			Hash string
		}
	}
	lockFetch     sync.RWMutex
	lockGetCommit sync.RWMutex
}

// Fetch calls FetchFunc.
func (mock *GitRepositoryMock) Fetch(ctx context.Context, hashes []string) error {
	callInfo := struct {
		Ctx    context.Context
		Hashes []string
	}{
		Ctx:    ctx,
		Hashes: hashes,
	}
	mock.lockFetch.Lock()
	mock.calls.Fetch = append(mock.calls.Fetch, callInfo)
	mock.lockFetch.Unlock()
	if mock.FetchFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.FetchFunc(ctx, hashes)
}

// FetchCalls gets all the calls that were made to Fetch.
// Check the length with:
//
//	len(mockedGitRepository.FetchCalls())
func (mock *GitRepositoryMock) FetchCalls() []struct {
	Ctx    context.Context
	Hashes []string
} {
	var calls []struct {
		Ctx    context.Context
		Hashes []string
	}
	mock.lockFetch.RLock()
	calls = mock.calls.Fetch
	mock.lockFetch.RUnlock()
	return calls
}

// GetCommit calls GetCommitFunc.
func (mock *GitRepositoryMock) GetCommit(hash string) (*domain.RepositoryCommit, error) {
	callInfo := struct {
		Hash string
	}{
		Hash: hash,
	}
	mock.lockGetCommit.Lock()
	mock.calls.GetCommit = append(mock.calls.GetCommit, callInfo)
	mock.lockGetCommit.Unlock()
	if mock.GetCommitFunc == nil {
		var (
			repositoryCommitOut *domain.RepositoryCommit
			errOut              error
		)
		return repositoryCommitOut, errOut
	}
	return mock.GetCommitFunc(hash)
}

// GetCommitCalls gets all the calls that were made to GetCommit.
// Check the length with:
//
//	len(mockedGitRepository.GetCommitCalls())
func (mock *GitRepositoryMock) GetCommitCalls() []struct {
	Hash string
} {
	var calls []struct {
		Hash string
	}
	mock.lockGetCommit.RLock()
	calls = mock.calls.GetCommit
	mock.lockGetCommit.RUnlock()
	return calls
}
