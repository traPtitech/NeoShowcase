// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/traPtitech/neoshowcase/pkg/domain"
	"sync"
)

// Ensure, that MariaDBManagerMock does implement domain.MariaDBManager.
// If this is not the case, regenerate this file with moq.
var _ domain.MariaDBManager = &MariaDBManagerMock{}

// MariaDBManagerMock is a mock implementation of domain.MariaDBManager.
//
//	func TestSomethingThatUsesMariaDBManager(t *testing.T) {
//
//		// make and configure a mocked domain.MariaDBManager
//		mockedMariaDBManager := &MariaDBManagerMock{
//			CloseFunc: func(ctx context.Context) error {
//				panic("mock out the Close method")
//			},
//			CreateFunc: func(ctx context.Context, args domain.CreateArgs) error {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(ctx context.Context, args domain.DeleteArgs) error {
//				panic("mock out the Delete method")
//			},
//			GetHostFunc: func() (string, int) {
//				panic("mock out the GetHost method")
//			},
//			IsExistFunc: func(ctx context.Context, dbname string) (bool, error) {
//				panic("mock out the IsExist method")
//			},
//		}
//
//		// use mockedMariaDBManager in code that requires domain.MariaDBManager
//		// and then make assertions.
//
//	}
type MariaDBManagerMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context) error

	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, args domain.CreateArgs) error

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, args domain.DeleteArgs) error

	// GetHostFunc mocks the GetHost method.
	GetHostFunc func() (string, int)

	// IsExistFunc mocks the IsExist method.
	IsExistFunc func(ctx context.Context, dbname string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args domain.CreateArgs
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args domain.DeleteArgs
		}
		// GetHost holds details about calls to the GetHost method.
		GetHost []struct {
		}
		// IsExist holds details about calls to the IsExist method.
		IsExist []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dbname is the dbname argument value.
			Dbname string
		}
	}
	lockClose   sync.RWMutex
	lockCreate  sync.RWMutex
	lockDelete  sync.RWMutex
	lockGetHost sync.RWMutex
	lockIsExist sync.RWMutex
}

// Close calls CloseFunc.
func (mock *MariaDBManagerMock) Close(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	if mock.CloseFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CloseFunc(ctx)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedMariaDBManager.CloseCalls())
func (mock *MariaDBManagerMock) CloseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *MariaDBManagerMock) Create(ctx context.Context, args domain.CreateArgs) error {
	callInfo := struct {
		Ctx  context.Context
		Args domain.CreateArgs
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	if mock.CreateFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CreateFunc(ctx, args)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedMariaDBManager.CreateCalls())
func (mock *MariaDBManagerMock) CreateCalls() []struct {
	Ctx  context.Context
	Args domain.CreateArgs
} {
	var calls []struct {
		Ctx  context.Context
		Args domain.CreateArgs
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *MariaDBManagerMock) Delete(ctx context.Context, args domain.DeleteArgs) error {
	callInfo := struct {
		Ctx  context.Context
		Args domain.DeleteArgs
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	if mock.DeleteFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeleteFunc(ctx, args)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedMariaDBManager.DeleteCalls())
func (mock *MariaDBManagerMock) DeleteCalls() []struct {
	Ctx  context.Context
	Args domain.DeleteArgs
} {
	var calls []struct {
		Ctx  context.Context
		Args domain.DeleteArgs
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// GetHost calls GetHostFunc.
func (mock *MariaDBManagerMock) GetHost() (string, int) {
	callInfo := struct {
	}{}
	mock.lockGetHost.Lock()
	mock.calls.GetHost = append(mock.calls.GetHost, callInfo)
	mock.lockGetHost.Unlock()
	if mock.GetHostFunc == nil {
		var (
			hostOut string
			portOut int
		)
		return hostOut, portOut
	}
	return mock.GetHostFunc()
}

// GetHostCalls gets all the calls that were made to GetHost.
// Check the length with:
//
//	len(mockedMariaDBManager.GetHostCalls())
func (mock *MariaDBManagerMock) GetHostCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetHost.RLock()
	calls = mock.calls.GetHost
	mock.lockGetHost.RUnlock()
	return calls
}

// IsExist calls IsExistFunc.
func (mock *MariaDBManagerMock) IsExist(ctx context.Context, dbname string) (bool, error) {
	callInfo := struct {
		Ctx    context.Context
		Dbname string
	}{
		Ctx:    ctx,
		Dbname: dbname,
	}
	mock.lockIsExist.Lock()
	mock.calls.IsExist = append(mock.calls.IsExist, callInfo)
	mock.lockIsExist.Unlock()
	if mock.IsExistFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.IsExistFunc(ctx, dbname)
}

// IsExistCalls gets all the calls that were made to IsExist.
// Check the length with:
//
//	len(mockedMariaDBManager.IsExistCalls())
func (mock *MariaDBManagerMock) IsExistCalls() []struct {
	Ctx    context.Context
	Dbname string
} {
	var calls []struct {
		Ctx    context.Context
		Dbname string
	}
	mock.lockIsExist.RLock()
	calls = mock.calls.IsExist
	mock.lockIsExist.RUnlock()
	return calls
}

// Ensure, that MongoDBManagerMock does implement domain.MongoDBManager.
// If this is not the case, regenerate this file with moq.
var _ domain.MongoDBManager = &MongoDBManagerMock{}

// MongoDBManagerMock is a mock implementation of domain.MongoDBManager.
//
//	func TestSomethingThatUsesMongoDBManager(t *testing.T) {
//
//		// make and configure a mocked domain.MongoDBManager
//		mockedMongoDBManager := &MongoDBManagerMock{
//			CloseFunc: func(ctx context.Context) error {
//				panic("mock out the Close method")
//			},
//			CreateFunc: func(ctx context.Context, args domain.CreateArgs) error {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(ctx context.Context, args domain.DeleteArgs) error {
//				panic("mock out the Delete method")
//			},
//			GetHostFunc: func() (string, int) {
//				panic("mock out the GetHost method")
//			},
//			IsExistFunc: func(ctx context.Context, dbname string) (bool, error) {
//				panic("mock out the IsExist method")
//			},
//		}
//
//		// use mockedMongoDBManager in code that requires domain.MongoDBManager
//		// and then make assertions.
//
//	}
type MongoDBManagerMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context) error

	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, args domain.CreateArgs) error

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, args domain.DeleteArgs) error

	// GetHostFunc mocks the GetHost method.
	GetHostFunc func() (string, int)

	// IsExistFunc mocks the IsExist method.
	IsExistFunc func(ctx context.Context, dbname string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args domain.CreateArgs
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args domain.DeleteArgs
		}
		// GetHost holds details about calls to the GetHost method.
		GetHost []struct {
		}
		// IsExist holds details about calls to the IsExist method.
		IsExist []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dbname is the dbname argument value.
			Dbname string
		}
	}
	lockClose   sync.RWMutex
	lockCreate  sync.RWMutex
	lockDelete  sync.RWMutex
	lockGetHost sync.RWMutex
	lockIsExist sync.RWMutex
}

// Close calls CloseFunc.
func (mock *MongoDBManagerMock) Close(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	if mock.CloseFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CloseFunc(ctx)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedMongoDBManager.CloseCalls())
func (mock *MongoDBManagerMock) CloseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *MongoDBManagerMock) Create(ctx context.Context, args domain.CreateArgs) error {
	callInfo := struct {
		Ctx  context.Context
		Args domain.CreateArgs
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	if mock.CreateFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CreateFunc(ctx, args)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedMongoDBManager.CreateCalls())
func (mock *MongoDBManagerMock) CreateCalls() []struct {
	Ctx  context.Context
	Args domain.CreateArgs
} {
	var calls []struct {
		Ctx  context.Context
		Args domain.CreateArgs
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *MongoDBManagerMock) Delete(ctx context.Context, args domain.DeleteArgs) error {
	callInfo := struct {
		Ctx  context.Context
		Args domain.DeleteArgs
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	if mock.DeleteFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeleteFunc(ctx, args)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedMongoDBManager.DeleteCalls())
func (mock *MongoDBManagerMock) DeleteCalls() []struct {
	Ctx  context.Context
	Args domain.DeleteArgs
} {
	var calls []struct {
		Ctx  context.Context
		Args domain.DeleteArgs
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// GetHost calls GetHostFunc.
func (mock *MongoDBManagerMock) GetHost() (string, int) {
	callInfo := struct {
	}{}
	mock.lockGetHost.Lock()
	mock.calls.GetHost = append(mock.calls.GetHost, callInfo)
	mock.lockGetHost.Unlock()
	if mock.GetHostFunc == nil {
		var (
			hostOut string
			portOut int
		)
		return hostOut, portOut
	}
	return mock.GetHostFunc()
}

// GetHostCalls gets all the calls that were made to GetHost.
// Check the length with:
//
//	len(mockedMongoDBManager.GetHostCalls())
func (mock *MongoDBManagerMock) GetHostCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetHost.RLock()
	calls = mock.calls.GetHost
	mock.lockGetHost.RUnlock()
	return calls
}

// IsExist calls IsExistFunc.
func (mock *MongoDBManagerMock) IsExist(ctx context.Context, dbname string) (bool, error) {
	callInfo := struct {
		Ctx    context.Context
		Dbname string
	}{
		Ctx:    ctx,
		Dbname: dbname,
	}
	mock.lockIsExist.Lock()
	mock.calls.IsExist = append(mock.calls.IsExist, callInfo)
	mock.lockIsExist.Unlock()
	if mock.IsExistFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.IsExistFunc(ctx, dbname)
}

// IsExistCalls gets all the calls that were made to IsExist.
// Check the length with:
//
//	len(mockedMongoDBManager.IsExistCalls())
func (mock *MongoDBManagerMock) IsExistCalls() []struct {
	Ctx    context.Context
	Dbname string
} {
	var calls []struct {
		Ctx    context.Context
		Dbname string
	}
	mock.lockIsExist.RLock()
	calls = mock.calls.IsExist
	mock.lockIsExist.RUnlock()
	return calls
}
